\documentclass[a4paper,10pt]{llncs}

\usepackage{graphicx}
\usepackage{multicol}
\usepackage{amsbsy,amscd,amsfonts,amssymb,amstext,amsmath,latexsym,theorem}

\pagestyle{plain}
\bibliographystyle{alpha}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title{{\normalsize Seminar: Formal Specification} \\[1ex]
  Security of Multithreaded Programs by Compilation\cite{Barthe07}}
\author{Pascal Wittmann, Advisor: Artem Starostin}
\institute{TU Darmstadt}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

{\bf Here comes the abstract!}

\section{Motivation}
\label{sec:motivation}
Barthe, Rezk, Russo and Sabelfeld introduced with
their paper \cite{Barthe07} a framework to guarantee
noninterference in multithreaded programs at byte-code
level. Noninterference is a security property which
says that a program does not leak sensitive information
to an adversary. Since more and more (mobile) devices handle
an increasing number of tasks, multithreading is widely used
to prevent lock ups (when e.g. establishing a 
network-connection). But often programs that are secure when they
are executed sequentially, leak information when they are
composed in parallel. This leads to an attractive channel of
information leakage.

The idea of Barthe et. al. was to close this channel by compiling
type information into the byte-code, which cause the scheduler to
treat the secure parts in a different way. The fact that many mobile
platforms already use some byte-code (e.g. Android uses a modification
of the JVM byte-code) may have been a reason for the decision to use
type-annotated byte-code.

\section{Introduction to research area}
\label{sec:introduction}
\section{Summary of the article}
\label{sec:discussion}
In this summary I will follow mainly the structure of the original
paper\cite{Barthe07} which is as follows. After the introduction the basic
terms and definitions for a multithreaded programs and the scheduler are
laid. After that the notion of security we want to achieve is presented.
Along with this a skeleton of a type system is described, which ensures
that a program typable in this type system is secure w.r.t the notion of
security. The proof that this holds is sketched in the following section.
In the last section the (by now) abstract framework is instantiated with a
concrete example.

\subsection{Syntax and Semantics of multithreaded programs}
\label{sec:syntaxsemantics}
A program is viewed as an abstract thing, which consists of a set of
program points $\mathcal{P}$ with a distinguished entry ($1$) and exit
(\texttt{exit}) point and a function that maps program points to
instructions.

These instructions are not further specified, but contain an instruction
to create a new thread (\texttt{start \textit{pc}} where pc is the start
instruction of the new thread).

Further, there is a relation $\mapsto$ that describes possible successor
instructions. \texttt{exit} is the only program point with no successor
and \texttt{start \textit{pc}} may only have a single successor (the
following program point).

The next thing introduced are the security levels. We assume the attacker
'is' a level $k$. From this assumption we can reduce every set of levels
w.l.o.g into $\{low, high\}$, where $low < high$, by mapping elements
that are no more sensitive than $k$ to $low$ and all other elements
including incomparable ones to $high$.

To connect programs and security levels, a \textit{security environment}
(se) is defined, which is used to prevent flows over implicit channels.
A security environment is a function that maps program points to security
levels. A program point $i$ is called high if $se(i) = high$, low if $se(i)
= low$ and always high if all points $j$ reachable (according to $\mapsto$)
from $i$ satisfy $se(j) = i$ and $i$ is a high program point.

Now we come to the semantics part. The main idea is to build a the semantics
for multithreaded programs by combining the semantics for sequential programs
with a scheduler.

All active\footnote{a thread is active from \texttt{start \textit{pc}} until
it reaches the \texttt{exit} point} threads are collected in a set $Thead$.
The state of the concurrent running threads ($ConcState$) is defined as the
product of the partial function space $(Thread \rightharpoonup LocState)$
and the set of global memories $GMemory$. Where $LocState$ is the internal
memory of a thread, from there no information can leak and the $GMemory$ is
the critical part of the system, because it is a memory shared between all
active threads.

At this point a first simplification can be made. Looking a state $s$ we can
first extract the active threads (\texttt{s.act}) by taking the domain of the first
component. According to a security environment we can classify these threads,
with respect to their current program point (\texttt{s.pc(tid)} where $tid \in Thread$),
into \textit{low} threads iff the current program point is low. In \textit{high}
threads iff the current program point is high. In \textit{always high} threads
iff the current program point is always high and in \textit{hidden} threads, iff
the current program point is high but not always high.

The latte two are the interesting ones. If a thread is \textit{always high} it
can not leaks any information into low, because it never only gets in touch
with low program points. So these threads can safely be interleaved by the
scheduler.

The \textit{hidden} threads are the ones we have to care about. These contain
obviously high information in the current program point, but have afterwards
instructions that deal with low information. Since the attacker can watch the
low part of the memory, chances are good that he can deduce high information
through changing low outputs. To prevent indirect flows that are introduced by
these hidden threads, the scheduler will be modified to treat these threads
in a special way. This will be done by 'hiding' these threads, therefore comes
the name of them.

To complete our multithreaded setup we need a scheduler. The scheduler will
operate on histories. A history is a list of pairs $(tid, l$), where $tid \in
Thread$ and $l \in Level$. In this history all threads chosen by the scheduler
are recorded.

At this point no concrete scheduler is defined to make the framework applicable
for a wide class of schedulers. A scheduler is in this class iff it can be
modeled as a function $pickt: ConcState \times History \rightharpoonup Thread$
which satisfies the following constraints:

\begin{enumerate}
\item It always picks an active thread
\item If there is a hidden thread, always choose high or always high threads
\item Only use low information and the low part of the history to choose a 
      new thread
\end{enumerate}

\subsection{Type system}
\label{sec:typesystem}
\subsection{Soundness}
\label{sec:soundness}
\subsection{Instantiation}
\label{sec:instantiation}

\section{Related Work}
\label{sec:relatedwork}
\section{Conclusion \& Outlook}
\label{sec:conclusion}

\bibliography{bibliography}

\end{document}
